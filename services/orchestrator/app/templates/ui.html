<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bluez Dubbing Studio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
        }

        @keyframes progressPulse {
            from {
                width: 20%;
            }
            to {
                width: 60%;
            }
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            transition: background 0.3s ease, color 0.3s ease;
        }

        body[data-theme="dark"] {
            background: #1E1F22;
            color: #f2f3f5;
        }

        body[data-theme="light"] {
            background: #f2f3f5;
            color: #1f2023;
        }

        body[data-theme="dark"] main {
            background: linear-gradient(145deg, rgba(35, 37, 41, 0.98), rgba(24, 25, 28, 0.92));
            border: 1px solid rgba(78, 80, 88, 0.6);
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.35);
        }

        body[data-theme="light"] main {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(242, 244, 248, 0.9));
            border: 1px solid rgba(208, 214, 222, 0.8);
            box-shadow: 0 20px 45px rgba(45, 55, 72, 0.15);
        }

        main {
            width: min(980px, 96vw);
            margin: 40px auto;
            border-radius: 22px;
            overflow: hidden;
            backdrop-filter: blur(18px);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 34px;
            gap: 20px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .brand img.icon {
            height: 66px;
            width: 66px;
            border-radius: 18px;
            object-fit: cover;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        }

        .brand img.logo {
            height: 64px;
        }
        .brand img {
            display: none;
        }

        .tagline {
            margin: 4px 0 0;
            font-size: 0.95rem;
            opacity: 0.7;
        }

        body[data-theme="light"] .tagline {
            color: #4f5660;
        }
        .icon-light,
        .logo-light {
            display: none;
        }

        body[data-theme="dark"] .icon-dark,
        body[data-theme="dark"] .logo-dark {
            display: block;
        }

        body[data-theme="light"] .icon-dark,
        body[data-theme="light"] .logo-dark {
            display: none;
        }

        body[data-theme="light"] .icon-light,
        body[data-theme="light"] .logo-light {
            display: block;
        }

        .theme-toggle {
            border: none;
            border-radius: 999px;
            padding: 10px 18px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #5865F2, #5865f2cc 70%, #7289da);
            color: #fff;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .theme-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 18px rgba(88, 101, 242, 0.35);
        }

        section {
            padding: 30px 34px 36px;
            display: grid;
            gap: 26px;
        }

        .previews {
            display: grid;
            gap: 18px;
            grid-template-columns: 1fr;
        }

        @media (min-width: 900px) {
            .previews {
                grid-template-columns: 1fr 1fr;
            }
        }

        .preview-card {
            border-radius: 18px;
            padding: 18px 20px 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            border: 1px solid rgba(108, 116, 138, 0.3);
            background: rgba(32, 34, 37, 0.6);
        }

        .download-progress {
            position: relative;
            margin-top: 8px;
            height: 6px;
            background: rgba(90, 96, 117, 0.25);
            border-radius: 999px;
            overflow: hidden;
        }

        .download-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, #5865F2, #7b83ff);
            border-radius: inherit;
            transition: width 0.2s ease;
        }

        .download-label {
            display: block;
            margin-top: 6px;
            font-size: 0.8rem;
            opacity: 0.7;
        }

body[data-theme="light"] .preview-card {
            background: rgba(248, 250, 254, 0.92);
            border: 1px solid rgba(193, 201, 216, 0.65);
        }

        .preview-card.empty video {
            display: none;
        }

        .preview-card.empty .preview-status {
            opacity: 0.7;
        }

        .preview-card video {
            width: 100%;
            border-radius: 14px;
            background: rgba(15, 16, 20, 0.85);
            min-height: 220px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .preview-header h2 {
            margin: 0;
            font-size: 1.05rem;
        }

        .preview-status {
            font-size: 0.82rem;
            opacity: 0.7;
        }

        form {
            display: grid;
            gap: 20px;
        }

        fieldset {
            border: 1px solid rgba(148, 156, 174, 0.3);
            border-radius: 16px;
            padding: 22px;
            display: grid;
            gap: 16px;
            background: rgba(49, 51, 56, 0.32);
        }

        body[data-theme="light"] fieldset {
            background: rgba(246, 248, 252, 0.9);
            border-color: rgba(188, 196, 212, 0.6);
        }

        legend {
            padding: 0 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-size: 0.74rem;
            opacity: 0.7;
        }

        label {
            display: grid;
            gap: 6px;
            font-size: 0.96rem;
            font-weight: 500;
        }

input[type="file"],
select,
input[type="text"],
input[type="url"] {
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 0.95rem;
            border: 1px solid rgba(111, 118, 136, 0.35);
            background: rgba(32, 34, 37, 0.9);
            color: inherit;
            transition: border 0.15s ease, box-shadow 0.15s ease;
        }

        body[data-theme="light"] input[type="file"],
        body[data-theme="light"] select,
        body[data-theme="light"] input[type="text"],
        body[data-theme="light"] input[type="url"] {
            background: #fff;
            border: 1px solid rgba(182, 189, 204, 0.7);
        }

        input[type="file"]::-webkit-file-upload-button {
            border: none;
            border-radius: 999px;
            padding: 6px 16px;
            background: #5865F2;
            color: #fff;
            cursor: pointer;
        }

        input[type="file"]:focus,
        select:focus,
        input[type="text"]:focus,
        input[type="url"]:focus {
            outline: none;
            border-color: #5865F2;
            box-shadow: 0 0 0 3px rgba(88, 101, 242, 0.2);
        }

        .download-bar {
            animation: none;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #5865F2;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
        }

        button.primary {
            border: none;
            border-radius: 999px;
            padding: 15px 26px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #5865F2, #4752C4);
            color: #fff;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button.primary:disabled {
            opacity: 0.55;
            cursor: wait;
        }

        button.primary:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(88, 101, 242, 0.4);
        }

        #log {
            border-radius: 16px;
            padding: 18px;
            max-height: 320px;
            overflow-y: auto;
            font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.85rem;
            line-height: 1.55;
            white-space: pre-line;
            border: 1px solid rgba(123, 132, 155, 0.25);
            background: rgba(28, 29, 33, 0.65);
        }

        body[data-theme="light"] #log {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(209, 214, 224, 0.7);
        }

        #results a {
            color: #7289DA;
            text-decoration: none;
        }

        #results a:hover {
            text-decoration: underline;
        }

        .flex {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .flex > label, .flex > .field {
            flex: 1 1 220px;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 0.8rem;
            border-radius: 999px;
            border: 1px solid rgba(114, 137, 218, 0.4);
            background: rgba(88, 101, 242, 0.18);
        }

        body[data-theme="light"] .badge {
            background: rgba(88, 101, 242, 0.15);
            border-color: rgba(88, 101, 242, 0.35);
            color: #3a3f52;
        }

        .hint {
            margin: -6px 0 0;
            font-size: 0.85rem;
            color: rgba(148, 156, 174, 0.75);
        }

        body[data-theme="light"] .hint {
            color: rgba(96, 102, 116, 0.75);
        }
    </style>
</head>
<body data-theme="dark">
<main>
    <header>
        <div class="brand">
            <img src="/assets/icon.png" alt="Bluez icon" class="icon icon-dark">
            <img src="/assets/icon2.png" alt="Bluez icon light" class="icon icon-light">
            <div>
                <img src="/assets/logo.png" alt="Bluez logo" class="logo logo-dark">
                <img src="/assets/logo2.png" alt="Bluez logo light" class="logo logo-light">
                <p class="tagline">Choose your vibe, dub in any language, monitor every step.</p>
            </div>
        </div>
        <button type="button" class="theme-toggle" id="theme-toggle">
            <span aria-hidden="true">üåô</span>
            <span class="theme-label">Dark</span>
        </button>
    </header>
    <section>
        <div class="previews">
            <div class="preview-card empty" id="source-preview-card">
                <div class="preview-header">
                    <h2>Source Preview</h2>
                    <span class="preview-status" id="source-preview-text">Waiting for media‚Ä¶</span>
                </div>
                <video id="source-video" controls playsinline></video>
            </div>
        </div>

        <form id="dub-form">
            <fieldset>
                <legend>Media</legend>
                <label>
                    Source Video / Audio
                    <input type="file" name="file" accept="video/*,audio/*">
                </label>
                <label>
                    Or Video Link
                    <input type="url" name="video_url" placeholder="https://www.youtube.com/watch?v=...">
                    <div class="download-progress" id="download-progress" hidden>
                        <div class="download-bar" id="download-bar"></div>
                        <span class="download-label" id="download-label">Downloading‚Ä¶</span>
                    </div>
                </label>
                <p class="hint">Provide either a local file or a public video URL (YouTube, Instagram, TikTok, ...).</p>
                <div class="flex">
                    <label>
                        Task
                        <select name="target_work">
                            <option value="dub">Dubbing</option>
                            <option value="sub">Subtitling</option>
                        </select>
                    </label>
                    <label>
                        Source Language
                        <input type="text" name="source_lang" list="language-list" placeholder="auto-detect (leave blank)">
                    </label>
                    <label>
                        Target Language
                        <input type="text" name="target_lang" list="language-list" placeholder="e.g. fr">
                    </label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Models</legend>
                <div class="flex">
                    <label>
                        ASR Model
                        <select name="asr_model" id="asr-model">
                            <option value="auto">Auto</option>
                        </select>
                    </label>
                    <label>
                        Translation Model
                        <select name="tr_model" id="tr-model">
                            <option value="auto">Auto</option>
                        </select>
                    </label>
                    <label>
                        TTS Model
                        <select name="tts_model" id="tts-model">
                            <option value="auto">Auto</option>
                        </select>
                    </label>
                </div>
                <label>
                    Audio Separation Model
                    <select name="sep_model" id="sep-model">
                        <option value="auto">Auto</option>
                    </select>
                </label>
            </fieldset>

            <fieldset>
                <legend>Strategies</legend>
                <div class="flex">
                    <label>
                        Translation Strategy
                        <select name="translation_strategy" id="translation-strategy"></select>
                    </label>
                    <label>
                        Dubbing Strategy
                        <select name="dubbing_strategy" id="dubbing-strategy"></select>
                    </label>
                    <label>
                        Subtitle Style
                        <select name="subtitle_style" id="subtitle-style">
                            <option value="">No subtitles</option>
                        </select>
                    </label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Toggles</legend>
                <div class="flex">
                    <label class="checkbox-row">
                        <input type="checkbox" id="persist-intermediate" name="persist_intermediate">
                        Keep intermediate artefacts
                    </label>
                    <label class="checkbox-row">
                        <input type="checkbox" id="audio-sep" name="audio_sep" checked>
                        Perform source separation
                    </label>
                    <label class="checkbox-row">
                        <input type="checkbox" id="vad-trim" name="perform_vad_trimming" checked>
                        Trim TTS with VAD
                    </label>
                    <label class="checkbox-row">
                        <input type="checkbox" id="sophisticated-timing" name="sophisticated_dub_timing" checked>
                        Sophisticated dub timing
                    </label>
                </div>
            </fieldset>

            <div class="actions">
                <button type="submit" id="run-btn" class="primary">Run dubbing pipeline</button>
                <span class="badge" id="status-badge">Idle</span>
            </div>
        </form>

        <div>
            <h2>Live Log</h2>
            <div id="log">Waiting‚Ä¶</div>
        </div>

        <div>
            <h2>Results</h2>
            <div id="results">No runs yet.</div>
            <div class="preview-card empty" id="result-preview-card">
                <div class="preview-header">
                    <h2>Result Preview</h2>
                    <span class="preview-status" id="result-preview-text">No output yet.</span>
                </div>
                <video id="result-video" controls playsinline></video>
            </div>
        </div>

        <datalist id="language-list"></datalist>
    </section>
</main>

<script>
const logEl = document.getElementById("log");
const resultsEl = document.getElementById("results");
const statusBadge = document.getElementById("status-badge");
const runBtn = document.getElementById("run-btn");
const formEl = document.getElementById("dub-form");
const sourceLangInput = document.querySelector("input[name='source_lang']");
const targetLangInput = document.querySelector("input[name='target_lang']");
const videoLinkInput = document.querySelector("input[name='video_url']");
const fileInput = document.querySelector("input[type='file']");
const themeToggle = document.getElementById("theme-toggle");
const themeLabel = document.querySelector("#theme-toggle .theme-label");
const sourcePreviewCard = document.getElementById("source-preview-card");
const sourcePreviewText = document.getElementById("source-preview-text");
const sourceVideoEl = document.getElementById("source-video");
const resultPreviewCard = document.getElementById("result-preview-card");
const resultPreviewText = document.getElementById("result-preview-text");
const resultVideoEl = document.getElementById("result-video");
const downloadProgress = document.getElementById("download-progress");
const downloadBar = document.getElementById("download-bar");
const downloadLabel = document.getElementById("download-label");

let optionsCache = null;
let asrModels = [];
let translationModels = [];
let ttsModels = [];

const languageMap = new Map();
const languageDisplay = typeof Intl !== "undefined" && Intl.DisplayNames
    ? new Intl.DisplayNames([navigator.language || "en"], { type: "language" })
    : null;
let sourceObjectUrl = null;
let resultObjectUrl = null;

function toLanguageLabel(code) {
    if (!code) return "";
    const lower = code.toLowerCase();
    const label = languageDisplay ? languageDisplay.of(lower) : null;
    if (!label) return lower;
    return label.charAt(0).toUpperCase() + label.slice(1);
}

function registerLanguage(code) {
    if (!code) return "";
    const normalized = code.toLowerCase();
    const label = toLanguageLabel(normalized);
    const display = `${label} (${normalized})`;
    const keys = [
        normalized,
        label.toLowerCase(),
        display.toLowerCase(),
        `${label} (${normalized.toUpperCase()})`.toLowerCase(),
    ];
    keys.forEach(key => {
        if (!languageMap.has(key)) {
            languageMap.set(key, normalized);
        }
    });
    return display;
}

function resolveLanguageCode(value) {
    if (!value) return "";
    const strValue = typeof value === "string" ? value : String(value);
    const trimmed = strValue.trim();
    if (!trimmed) return "";
    const match = trimmed.match(/\(([a-zA-Z-]+)\)\s*$/);
    if (match && match[1]) {
        const candidate = match[1].toLowerCase();
        if (languageMap.has(candidate)) {
            return languageMap.get(candidate);
        }
        return candidate;
    }
    const key = trimmed.toLowerCase();
    if (languageMap.has(key)) {
        return languageMap.get(key);
    }
    return key;
}

function updateSourcePreview(src, label, { keepExisting = false, objectUrl = null } = {}) {
    if (!keepExisting && sourceObjectUrl) {
        URL.revokeObjectURL(sourceObjectUrl);
        sourceObjectUrl = null;
    }

    if (!src) {
        sourceVideoEl.removeAttribute("src");
        sourceVideoEl.load();
        sourcePreviewCard.classList.add("empty");
        sourcePreviewText.textContent = label || "Waiting for media‚Ä¶";
        return;
    }

    sourceVideoEl.src = src;
    sourceVideoEl.load();
    sourcePreviewCard.classList.remove("empty");
    sourcePreviewText.textContent = label || "";
    if (objectUrl) {
        sourceObjectUrl = objectUrl;
    }
}

function updateDownloadProgress({ active, progress = null, label = "" }) {
    if (!downloadProgress) return;
    if (!active) {
        downloadProgress.hidden = true;
        downloadBar.style.width = "0%";
        downloadBar.style.animation = "none";
        if (label) {
            downloadLabel.textContent = label;
            downloadLabel.hidden = false;
        } else {
            downloadLabel.hidden = true;
        }
        return;
    }
    downloadProgress.hidden = false;
        downloadLabel.hidden = false;
        downloadLabel.textContent = label || "Downloading‚Ä¶";
        if (progress !== null) {
            const pct = Math.min(100, Math.max(0, progress));
            downloadBar.style.width = `${pct}%`;
            downloadBar.style.animation = "none";
        } else {
            downloadBar.style.width = "30%";
            downloadBar.style.animation = "progressPulse 1s ease-in-out infinite alternate";
        }
}

function updateResultPreview(src, label, { objectUrl = null } = {}) {
    if (resultObjectUrl) {
        URL.revokeObjectURL(resultObjectUrl);
        resultObjectUrl = null;
    }

    if (!src) {
        resultVideoEl.removeAttribute("src");
        resultVideoEl.load();
        resultPreviewCard.classList.add("empty");
        resultPreviewText.textContent = label || "No output yet.";
        return;
    }

    resultVideoEl.src = src;
    resultVideoEl.load();
    resultPreviewCard.classList.remove("empty");
    resultPreviewText.textContent = label || "";
    if (objectUrl) {
        resultObjectUrl = objectUrl;
    }
}

const THEME_KEY = "bluez-ui-theme";
const themeIconSpan = themeToggle ? themeToggle.querySelector("span[aria-hidden='true']") : null;

function applyTheme(theme) {
    const normalized = theme === "light" ? "light" : "dark";
    document.body.dataset.theme = normalized;
    document.body.style.colorScheme = normalized;
    if (themeLabel) {
        themeLabel.textContent = normalized === "dark" ? "Dark" : "Light";
    }
    if (themeIconSpan) {
        themeIconSpan.textContent = normalized === "dark" ? "üåô" : "‚òÄÔ∏è";
    }
}

if (themeToggle) {
    const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    const storedTheme = localStorage.getItem(THEME_KEY) || (prefersDark ? "dark" : "light");
    applyTheme(storedTheme);

    themeToggle.addEventListener("click", () => {
        const next = document.body.dataset.theme === "dark" ? "light" : "dark";
        applyTheme(next);
        localStorage.setItem(THEME_KEY, next);
    });
} else {
    document.body.dataset.theme = "dark";
    document.body.style.colorScheme = "dark";
}

updateSourcePreview(null, "Waiting for media‚Ä¶");
updateResultPreview(null, "No output yet.");

async function fetchOptions() {
    const resp = await fetch("/ui/options");
    if (!resp.ok) throw new Error("Unable to load model registry");
    optionsCache = await resp.json();
    populateSelectors(optionsCache);
}

function populateSelectors(opts) {
    const asrSelect = document.getElementById("asr-model");
    const trSelect = document.getElementById("tr-model");
    const ttsSelect = document.getElementById("tts-model");
    const sepSelect = document.getElementById("sep-model");
    const translationStrategy = document.getElementById("translation-strategy");
    const dubbingStrategy = document.getElementById("dubbing-strategy");
    const subtitleStyle = document.getElementById("subtitle-style");
    const languageList = document.getElementById("language-list");

    asrModels = opts.asr_models || [];
    translationModels = opts.translation_models || [];
    ttsModels = opts.tts_models || [];

    const codes = new Set();
    [asrModels, translationModels, ttsModels].forEach(group => {
        group.forEach(model => (model.languages || []).forEach(lang => codes.add(lang)));
    });

    function refreshModelSelect(select, models, languageCode) {
        const previous = select.value;
        select.innerHTML = "";
        const autoOption = document.createElement("option");
        autoOption.value = "auto";
        autoOption.textContent = "Auto";
        select.appendChild(autoOption);

        models.forEach(model => {
            const supportsLanguage =
                !languageCode ||
                !(model.languages || []).length ||
                model.languages.includes(languageCode);
            if (!supportsLanguage) {
                return;
            }
            const option = document.createElement("option");
            option.value = model.key;
            option.textContent = model.key;
            select.appendChild(option);
        });

        if ([...select.options].some(opt => opt.value === previous)) {
            select.value = previous;
        }
    }

    const initSourceCode = resolveLanguageCode(sourceLangInput.value);
    const initTargetCode = resolveLanguageCode(targetLangInput.value) || initSourceCode;
    refreshModelSelect(asrSelect, asrModels, initSourceCode);
    refreshModelSelect(trSelect, translationModels, initTargetCode);
    refreshModelSelect(ttsSelect, ttsModels, resolveLanguageCode(targetLangInput.value));

    opts.audio_separation_models.forEach(group => {
        const optGroup = document.createElement("optgroup");
        optGroup.label = group.architecture;
        group.models.forEach(model => {
            const opt = document.createElement("option");
            opt.value = model.filename;
            opt.textContent = `${model.filename} (${model.stems.join(" + ")})`;
            optGroup.appendChild(opt);
        });
        sepSelect.appendChild(optGroup);
    });

    opts.translation_strategies.forEach(strategy => {
        const option = document.createElement("option");
        option.value = strategy;
        option.textContent = strategy;
        translationStrategy.appendChild(option);
    });

    opts.dubbing_strategies.forEach(strategy => {
        const option = document.createElement("option");
        option.value = strategy;
        option.textContent = strategy;
        dubbingStrategy.appendChild(option);
    });

    opts.subtitle_styles.forEach(style => {
        ["Desktop", "Mobile"].forEach(mode => {
            const value = mode === "Mobile" ? `${style}_mobile` : style;
            const option = document.createElement("option");
            option.value = value;
            option.textContent = `${style} (${mode})`;
            subtitleStyle.appendChild(option);
        });
    });

    const preferredOrder = ["en", "fr"];
    const languageEntries = Array.from(codes).map(code => ({
        code: code.toLowerCase(),
        display: registerLanguage(code),
    }));

    languageEntries.sort((a, b) => {
        const idxA = preferredOrder.indexOf(a.code);
        const idxB = preferredOrder.indexOf(b.code);
        if (idxA !== -1 && idxB !== -1) return idxA - idxB;
        if (idxA !== -1) return -1;
        if (idxB !== -1) return 1;
        return a.display.localeCompare(b.display);
    });

    function fillLanguageOptions(filter = "") {
        const normalized = filter.trim().toLowerCase();
        const suggestions = normalized
            ? languageEntries.filter(entry =>
                  entry.display.toLowerCase().includes(normalized) || entry.code.includes(normalized)
              )
            : languageEntries;
        languageList.innerHTML = "";
        suggestions.forEach(entry => {
            const opt = document.createElement("option");
            opt.value = entry.display;
            opt.dataset.code = entry.code;
            languageList.appendChild(opt);
        });
    }

    fillLanguageOptions();

    function updateLanguageSuggestions(inputEl) {
        fillLanguageOptions(inputEl.value);
    }

    sourceLangInput.addEventListener("input", () => {
        updateLanguageSuggestions(sourceLangInput);
        const sourceCode = resolveLanguageCode(sourceLangInput.value);
        const targetCode = resolveLanguageCode(targetLangInput.value) || sourceCode;
        refreshModelSelect(asrSelect, asrModels, sourceCode);
        refreshModelSelect(trSelect, translationModels, targetCode);
    });
    targetLangInput.addEventListener("input", () => {
        updateLanguageSuggestions(targetLangInput);
        const targetCode = resolveLanguageCode(targetLangInput.value);
        const sourceCode = resolveLanguageCode(sourceLangInput.value);
        refreshModelSelect(trSelect, translationModels, targetCode || sourceCode);
        refreshModelSelect(ttsSelect, ttsModels, targetCode);
    });
}

function appendLog(message) {
    const now = new Date().toLocaleTimeString();
    logEl.textContent += `\n[${now}] ${message}`;
    logEl.scrollTop = logEl.scrollHeight;
}

fileInput.addEventListener("change", () => {
    if (sourceObjectUrl) {
        URL.revokeObjectURL(sourceObjectUrl);
        sourceObjectUrl = null;
    }
    if (fileInput.files && fileInput.files.length > 0) {
        const blobUrl = URL.createObjectURL(fileInput.files[0]);
        updateSourcePreview(blobUrl, "Local upload", { objectUrl: blobUrl });
    } else if (!videoLinkInput.value.trim()) {
        updateSourcePreview(null, "Waiting for media‚Ä¶");
    }
});

videoLinkInput.addEventListener("input", () => {
    if (videoLinkInput.value.trim() && (!fileInput.files || fileInput.files.length === 0)) {
        updateSourcePreview(null, "Remote media will be downloaded on run‚Ä¶");
        updateDownloadProgress({ active: false, label: "" });
    }
});

function resetLog() {
    logEl.textContent = "Waiting‚Ä¶";
}

function setStatus(text, tone = "idle") {
    statusBadge.textContent = text;
    const palette = {
        idle: "rgba(59, 130, 246, 0.18)",
        running: "rgba(52, 211, 153, 0.2)",
        success: "rgba(34, 197, 94, 0.25)",
        error: "rgba(239, 68, 68, 0.25)"
    };
    statusBadge.style.background = palette[tone] || palette.idle;
    statusBadge.style.borderColor = palette[tone] || palette.idle;
}

function renderResults(payload) {
    if (!payload) {
        resultsEl.textContent = "Pipeline finished without a payload.";
        return;
    }
    const { final_video, final_audio, speech_track, subtitles, models, timings, workspace_id, source_media, source_video } = payload;

    function renderLink(item, label) {
        if (!item || !item.url) return `<li>${label}: unavailable</li>`;
        return `<li>${label}: <a href="${item.url}" target="_blank" rel="noopener">${item.path}</a></li>`;
    }

    resultsEl.innerHTML = `
        <p><strong>Workspace:</strong> ${workspace_id || "n/a"}</p>
        <p><strong>Source:</strong> ${source_media || "n/a"}</p>
        <p><strong>Models:</strong> ASR=${models?.asr || "n/a"}, Translation=${models?.translation || "n/a"}, TTS=${models?.tts || "n/a"}</p>
        <ul>
            ${renderLink(source_video, "Source video")}
            ${renderLink(final_video, "Final video")}
            ${renderLink(final_audio, "Final dubbed audio")}
            ${renderLink(speech_track, "Speech track")}
        </ul>
        <details>
            <summary>Subtitles</summary>
            <ul>
                ${renderLink(subtitles?.original?.srt, "Original SRT")}
                ${renderLink(subtitles?.original?.vtt, "Original VTT")}
                ${renderLink(subtitles?.aligned?.srt, "Dubbed SRT")}
                ${renderLink(subtitles?.aligned?.vtt, "Dubbed VTT")}
            </ul>
        </details>
        <details>
            <summary>Timings</summary>
            <ul>
                ${Object.entries(timings || {}).map(([step, duration]) => `<li>${step}: ${duration.toFixed(2)}s</li>`).join("")}
            </ul>
        </details>
    `;
}

formEl.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!optionsCache) {
        appendLog("‚ö†Ô∏è Model registry not loaded.");
        return;
    }

    const formData = new FormData(formEl);
    const hasFile = fileInput.files && fileInput.files.length > 0;
    const linkValue = videoLinkInput.value.trim();
    if (!hasFile && !linkValue) {
        appendLog("‚ö†Ô∏è Provide a media file or a video link.");
        setStatus("Error", "error");
        return;
    }

    if (linkValue) {
        formData.set("video_url", linkValue);
    } else {
        formData.delete("video_url");
    }

    if (!hasFile) {
        formData.delete("file");
    }

    const resolvedSource = resolveLanguageCode(formData.get("source_lang"));
    const resolvedTarget = resolveLanguageCode(formData.get("target_lang"));
    formData.set("source_lang", resolvedSource);
    formData.set("target_lang", resolvedTarget);

    formData.set("audio_sep", document.getElementById("audio-sep").checked ? "true" : "false");
    formData.set("perform_vad_trimming", document.getElementById("vad-trim").checked ? "true" : "false");
    formData.set("sophisticated_dub_timing", document.getElementById("sophisticated-timing").checked ? "true" : "false");
    formData.set("persist_intermediate", document.getElementById("persist-intermediate").checked ? "true" : "false");

    resetLog();
    logEl.textContent = "Starting pipeline‚Ä¶";
    setStatus("Running", "running");
    if (!hasFile && linkValue) {
        updateSourcePreview(null, "Downloading media‚Ä¶");
    }
    updateResultPreview(null, "Processing output‚Ä¶");
    runBtn.disabled = true;

    try {
        const response = await fetch("/ui/run", {
            method: "POST",
            body: formData,
        });
        if (!response.ok) {
            throw new Error(`Request failed: ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n\n");
            buffer = lines.pop() || "";

            for (const block of lines) {
                const line = block.split("\n").find(l => l.startsWith("data:"));
                if (!line) continue;
                const data = JSON.parse(line.slice(5).trim());
                handleEvent(data);
            }
        }

        if (buffer.trim()) {
            const line = buffer.split("\n").find(l => l.startsWith("data:"));
            if (line) {
                const data = JSON.parse(line.slice(5).trim());
                handleEvent(data);
            }
        }
    } catch (err) {
        appendLog(`‚ùå ${err.message}`);
        setStatus("Error", "error");
    } finally {
        runBtn.disabled = false;
    }
});

function handleEvent(event) {
    if (!event || !event.type) return;
    switch (event.type) {
        case "step":
            if (event.event === "start") {
                appendLog(`‚ñ∂Ô∏è  ${event.step}‚Ä¶`);
            } else if (event.event === "end") {
                appendLog(`‚úÖ ${event.step} (${event.duration.toFixed(2)}s)`);
            }
            break;
        case "result":
            appendLog("üéâ Pipeline completed.");
            setStatus("Done", "success");
            renderResults(event.result);
            if (event.result?.source_video?.url) {
                updateSourcePreview(event.result.source_video.url, "Source (workspace)");
            }
            if (event.result?.final_video?.url) {
                updateResultPreview(event.result.final_video.url, "Rendered output");
            }
            break;
        case "status":
            if (event.event === "download_start") {
                appendLog(`‚¨áÔ∏è Downloading remote media: ${event.url || ""}`);
                updateSourcePreview(null, "Downloading media‚Ä¶", { keepExisting: false });
                updateDownloadProgress({ active: true, label: "Downloading‚Ä¶" });
            } else if (event.event === "download_complete") {
                appendLog(`‚úÖ Download complete`);
                sourcePreviewText.textContent = "Download complete. Preparing source‚Ä¶";
                updateDownloadProgress({ active: false, label: "Download complete." });
            } else if (event.event === "download_progress") {
                if (typeof event.total === "number" && typeof event.downloaded === "number") {
                    const pct = Math.round((event.downloaded / event.total) * 100);
                    updateDownloadProgress({ active: true, progress: pct, label: `Downloading‚Ä¶ ${pct}%` });
                } else {
                    updateDownloadProgress({ active: true, progress: null, label: "Downloading‚Ä¶" });
                }
            } else {
                appendLog(`‚ÑπÔ∏è ${event.event || "status"}`);
            }
            break;
        case "source_preview":
            if (event.preview && event.preview.url) {
                updateSourcePreview(event.preview.url, "Source ready");
                appendLog("üé¨ Source preview available.");
            }
            break;
        case "error":
            appendLog(`‚ùå Error: ${event.message || "unknown failure"}`);
            setStatus("Error", "error");
            break;
        case "complete":
            appendLog("üèÅ Stream closed.");
            break;
        default:
            appendLog(`‚ÑπÔ∏è ${JSON.stringify(event)}`);
    }
}

fetchOptions().catch(err => appendLog(`‚ö†Ô∏è ${err.message}`));
</script>
</body>
</html>
