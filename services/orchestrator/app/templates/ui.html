<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bluez Dubbing Studio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
        }

        @keyframes progressPulse {
            from {
                width: 20%;
            }
            to {
                width: 60%;
            }
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            transition: background 0.3s ease, color 0.3s ease;
        }

        body[data-theme="dark"] {
            background: #1E1F22;
            color: #f2f3f5;
        }

        body[data-theme="light"] {
            background: #f2f3f5;
            color: #1f2023;
        }

        body[data-theme="dark"] main {
            background: linear-gradient(145deg, rgba(35, 37, 41, 0.98), rgba(24, 25, 28, 0.92));
            border: 1px solid rgba(78, 80, 88, 0.6);
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.35);
        }

        body[data-theme="light"] main {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(242, 244, 248, 0.9));
            border: 1px solid rgba(208, 214, 222, 0.8);
            box-shadow: 0 20px 45px rgba(45, 55, 72, 0.15);
        }

        main {
            width: min(980px, 96vw);
            margin: 40px auto;
            border-radius: 22px;
            overflow: hidden;
            backdrop-filter: blur(18px);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 34px;
            gap: 20px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .brand img.icon {
            height: 66px;
            width: 66px;
            border-radius: 18px;
            object-fit: cover;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        }

        .brand img.logo {
            height: 64px;
        }
        .brand img {
            display: none;
        }

        .tagline {
            margin: 4px 0 0;
            font-size: 0.95rem;
            opacity: 0.7;
        }

        body[data-theme="light"] .tagline {
            color: #4f5660;
        }
        .icon-light,
        .logo-light {
            display: none;
        }

        body[data-theme="dark"] .icon-dark,
        body[data-theme="dark"] .logo-dark {
            display: block;
        }

        body[data-theme="light"] .icon-dark,
        body[data-theme="light"] .logo-dark {
            display: none;
        }

        body[data-theme="light"] .icon-light,
        body[data-theme="light"] .logo-light {
            display: block;
        }

        .theme-toggle {
            border: none;
            border-radius: 999px;
            padding: 10px 18px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #5865F2, #5865f2cc 70%, #7289da);
            color: #fff;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .theme-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 18px rgba(88, 101, 242, 0.35);
        }

        section {
            padding: 30px 34px 36px;
            display: grid;
            gap: 26px;
        }

        .previews {
            display: grid;
            gap: 18px;
            grid-template-columns: 1fr;
            justify-items: center;
        }

        @media (min-width: 900px) {
            .previews {
                grid-template-columns: 1fr 1fr;
            }
        }

        .preview-card {
            border-radius: 18px;
            padding: 18px 20px 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            border: 1px solid rgba(108, 116, 138, 0.3);
            background: rgba(32, 34, 37, 0.6);
            width: min(100%, 520px);
            margin: 0 auto;
        }

        .download-progress {
            position: relative;
            margin-top: 8px;
            height: 6px;
            background: rgba(90, 96, 117, 0.25);
            border-radius: 999px;
            overflow: hidden;
        }

        .download-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, #5865F2, #7b83ff);
            border-radius: inherit;
            transition: width 0.2s ease;
        }

        .download-label {
            display: block;
            margin-top: 6px;
            font-size: 0.8rem;
            opacity: 0.7;
        }

body[data-theme="light"] .preview-card {
            background: rgba(248, 250, 254, 0.92);
            border: 1px solid rgba(193, 201, 216, 0.65);
        }

        .preview-card.empty video {
            display: none;
        }

        .preview-card.empty .preview-status {
            opacity: 0.7;
        }

        .preview-card video {
            width: 100%;
            border-radius: 14px;
            background: rgba(15, 16, 20, 0.85);
            min-height: 220px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .preview-controls {
            display: flex;
            justify-content: flex-end;
        }

        .preview-controls label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }

        .preview-controls select {
            min-width: 150px;
            border-radius: 10px;
            padding: 8px 10px;
        }

        .preview-header h2 {
            margin: 0;
            font-size: 1.05rem;
        }

        .preview-status {
            font-size: 0.82rem;
            opacity: 0.7;
        }

        form {
            display: grid;
            gap: 20px;
        }

        fieldset {
            border: 1px solid rgba(148, 156, 174, 0.3);
            border-radius: 16px;
            padding: 22px;
            display: grid;
            gap: 16px;
            background: rgba(49, 51, 56, 0.32);
        }

        body[data-theme="light"] fieldset {
            background: rgba(246, 248, 252, 0.9);
            border-color: rgba(188, 196, 212, 0.6);
        }

        legend {
            padding: 0 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-size: 0.74rem;
            opacity: 0.7;
        }

        label {
            display: grid;
            gap: 6px;
            font-size: 0.96rem;
            font-weight: 500;
        }

input[type="file"],
select,
input[type="text"],
input[type="url"] {
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 0.95rem;
            border: 1px solid rgba(111, 118, 136, 0.35);
            background: rgba(32, 34, 37, 0.9);
            color: inherit;
            transition: border 0.15s ease, box-shadow 0.15s ease;
        }

        body[data-theme="light"] input[type="file"],
        body[data-theme="light"] select,
        body[data-theme="light"] input[type="text"],
        body[data-theme="light"] input[type="url"] {
            background: #fff;
            border: 1px solid rgba(182, 189, 204, 0.7);
        }

        input[type="file"]::-webkit-file-upload-button {
            border: none;
            border-radius: 999px;
            padding: 6px 16px;
            background: #5865F2;
            color: #fff;
            cursor: pointer;
        }

        input[type="file"]:focus,
        select:focus,
        input[type="text"]:focus,
        input[type="url"]:focus {
            outline: none;
            border-color: #5865F2;
            box-shadow: 0 0 0 3px rgba(88, 101, 242, 0.2);
        }

        .download-bar {
            animation: none;
        }

input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #5865F2;
        }

.tag-input {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.04);
        min-height: 44px;
    }

    body[data-theme="light"] .tag-input {
        border-color: rgba(31, 41, 55, 0.15);
        background: rgba(31, 41, 55, 0.04);
    }

    .tag-input input {
        flex: 1;
        min-width: 140px;
        border: none;
        background: transparent;
        color: inherit;
        padding: 6px 4px;
        font-size: 0.95rem;
        outline: none;
    }

    .tag-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.18);
        font-size: 0.85rem;
        color: inherit;
    }

    body[data-theme="light"] .tag-badge {
        background: rgba(59, 130, 246, 0.12);
    }

    .tag-badge button {
        border: none;
        background: none;
        color: inherit;
        cursor: pointer;
        padding: 0;
        font-size: 1rem;
        line-height: 1;
    }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
        }

        button.primary {
            border: none;
            border-radius: 999px;
            padding: 15px 26px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #5865F2, #4752C4);
            color: #fff;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button.primary:disabled {
            opacity: 0.55;
            cursor: wait;
        }

        button.primary:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(88, 101, 242, 0.4);
        }

        button.secondary {
            border: 1px solid rgba(88, 101, 242, 0.4);
            border-radius: 999px;
            padding: 12px 22px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            background: transparent;
            color: inherit;
            transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
        }

        button.secondary:not(:disabled):hover {
            background: rgba(88, 101, 242, 0.1);
            color: #7289DA;
        }

        button.secondary:disabled {
            opacity: 0.45;
            cursor: default;
        }

        #log {
            border-radius: 16px;
            padding: 18px;
            max-height: 320px;
            overflow-y: auto;
            font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.85rem;
            line-height: 1.55;
            white-space: pre-line;
            border: 1px solid rgba(123, 132, 155, 0.25);
            background: rgba(28, 29, 33, 0.65);
        }

        body[data-theme="light"] #log {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(209, 214, 224, 0.7);
        }

        #results a {
            color: #7289DA;
            text-decoration: none;
        }

        #results a:hover {
            text-decoration: underline;
        }

        .flex {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .flex > label, .flex > .field {
            flex: 1 1 220px;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .actions .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 0.8rem;
            border-radius: 999px;
            border: 1px solid rgba(114, 137, 218, 0.4);
            background: rgba(88, 101, 242, 0.18);
        }

        body[data-theme="light"] .badge {
            background: rgba(88, 101, 242, 0.15);
            border-color: rgba(88, 101, 242, 0.35);
            color: #3a3f52;
        }

        .hint {
            margin: -6px 0 0;
            font-size: 0.85rem;
            color: rgba(148, 156, 174, 0.75);
        }

        body[data-theme="light"] .hint {
            color: rgba(96, 102, 116, 0.75);
        }
    </style>
</head>
<body data-theme="dark">
<main>
    <header>
        <div class="brand">
            <img src="/assets/icon.png" alt="Bluez icon" class="icon icon-dark">
            <img src="/assets/icon2.png" alt="Bluez icon light" class="icon icon-light">
            <div>
                <img src="/assets/logo.png" alt="Bluez logo" class="logo logo-dark">
                <img src="/assets/logo2.png" alt="Bluez logo light" class="logo logo-light">
                <p class="tagline">Choose your vibe, dub in any language, monitor every step.</p>
            </div>
        </div>
        <button type="button" class="theme-toggle" id="theme-toggle">
            <span aria-hidden="true">ðŸŒ™</span>
            <span class="theme-label">Dark</span>
        </button>
    </header>
    <section>
        <div class="previews">
            <div class="preview-card empty" id="source-preview-card">
                <div class="preview-header">
                    <h2>Source Preview</h2>
                    <span class="preview-status" id="source-preview-text">Waiting for mediaâ€¦</span>
                </div>
                <video id="source-video" controls playsinline></video>
            </div>
        </div>

        <form id="dub-form">
            <input type="hidden" name="reuse_media_token" id="reuse-media-token">
            <fieldset>
                <legend>Media</legend>
                <label>
                    Source Video / Audio
                    <input type="file" name="file" accept="video/*,audio/*">
                </label>
                <label>
                    Or Video Link
                    <input type="url" name="video_url" placeholder="https://www.youtube.com/watch?v=...">
                    <div class="download-progress" id="download-progress" hidden>
                        <div class="download-bar" id="download-bar"></div>
                        <span class="download-label" id="download-label">Downloadingâ€¦</span>
                    </div>
                </label>
                <p class="hint">Provide either a local file or a public video URL (YouTube, Instagram, TikTok, ...).</p>
                <div class="flex">
                    <label>
                        Task
                        <select name="target_work">
                            <option value="dub">Dubbing</option>
                            <option value="sub">Subtitling</option>
                        </select>
                    </label>
                    <label>
                        Source Language
                        <input type="text" name="source_lang" list="language-list" placeholder="auto-detect (leave blank)">
                    </label>
                    <label>
                        Target Languages
                        <div class="tag-input" id="target-lang-field">
                            <div class="tag-input__tags" id="target-lang-tags"></div>
                            <input type="text" id="target-lang-input" list="language-list" placeholder="Type code and press Enter">
                        </div>
                    </label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Models</legend>
                <div class="flex">
                    <label>
                        ASR Model
                        <select name="asr_model" id="asr-model">
                            <option value="auto">Auto</option>
                        </select>
                    </label>
                    <label>
                        Translation Model
                        <select name="tr_model" id="tr-model">
                            <option value="auto">Auto</option>
                        </select>
                    </label>
                    <label>
                        TTS Model
                        <select name="tts_model" id="tts-model">
                            <option value="auto">Auto</option>
                        </select>
                    </label>
                </div>
                <label>
                    Audio Separation Model
                    <select name="sep_model" id="sep-model">
                        <option value="auto">Auto</option>
                    </select>
                </label>
            </fieldset>

            <fieldset>
                <legend>Strategies</legend>
                <div class="flex">
                    <label>
                        Translation Strategy
                        <select name="translation_strategy" id="translation-strategy"></select>
                    </label>
                    <label>
                        Dubbing Strategy
                        <select name="dubbing_strategy" id="dubbing-strategy"></select>
                    </label>
                    <label>
                        Subtitle Style
                        <select name="subtitle_style" id="subtitle-style">
                            <option value="">No subtitles</option>
                        </select>
                    </label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Diarization</legend>
                <div class="flex">
                    <label>
                        Min speakers
                        <input type="number" name="min_speakers" min="1" placeholder="leave blank for auto">
                    </label>
                    <label>
                        Max speakers
                        <input type="number" name="max_speakers" min="1" placeholder="leave blank for auto">
                    </label>
                </div>
                <p class="hint">Provide speaker count hints when known to improve diarization accuracy.</p>
            </fieldset>

            <fieldset>
                <legend>Toggles</legend>
                <div class="flex">
                    <label class="checkbox-row">
                        <input type="checkbox" id="persist-intermediate" name="persist_intermediate">
                        Keep intermediate artefacts
                    </label>
                    <label class="checkbox-row">
                        <input type="checkbox" id="audio-sep" name="audio_sep" checked>
                        Perform source separation
                    </label>
                    <label class="checkbox-row">
                        <input type="checkbox" id="vad-trim" name="perform_vad_trimming" checked>
                        Trim TTS with VAD
                    </label>
                    <label class="checkbox-row">
                        <input type="checkbox" id="sophisticated-timing" name="sophisticated_dub_timing" checked>
                        Sophisticated dub timing
                    </label>
                </div>
            </fieldset>

            <div class="actions">
                <div class="button-group">
                    <button type="submit" id="run-btn" class="primary">Run dubbing pipeline</button>
                    <button type="button" id="interrupt-btn" class="secondary" disabled hidden>Interrupt run</button>
                </div>
                <span class="badge" id="status-badge">Idle</span>
            </div>
        </form>

        <div>
            <h2>Live Log</h2>
            <div id="log">Waitingâ€¦</div>
        </div>

        <div>
            <h2>Results</h2>
            <div id="results">No runs yet.</div>
            <div class="preview-card empty" id="result-preview-card">
                <div class="preview-header">
                    <h2>Result Preview</h2>
                    <span class="preview-status" id="result-preview-text">No output yet.</span>
                </div>
                <div class="preview-controls">
                    <label>
                        Language
                        <select id="result-language-select" disabled>
                            <option value="">No output</option>
                        </select>
                    </label>
                </div>
                <video id="result-video" controls playsinline></video>
            </div>
        </div>

        <datalist id="language-list"></datalist>
    </section>
</main>

<script>
const logEl = document.getElementById("log");
const resultsEl = document.getElementById("results");
const statusBadge = document.getElementById("status-badge");
const runBtn = document.getElementById("run-btn");
const interruptBtn = document.getElementById("interrupt-btn");
const formEl = document.getElementById("dub-form");
const sourceLangInput = document.querySelector("input[name='source_lang']");
const targetLangInput = document.getElementById("target-lang-input");
const targetLangTags = document.getElementById("target-lang-tags");
const targetLangField = document.getElementById("target-lang-field");
const videoLinkInput = document.querySelector("input[name='video_url']");
const fileInput = document.querySelector("input[type='file']");
const themeToggle = document.getElementById("theme-toggle");
const themeLabel = document.querySelector("#theme-toggle .theme-label");
const sourcePreviewCard = document.getElementById("source-preview-card");
const sourcePreviewText = document.getElementById("source-preview-text");
const sourceVideoEl = document.getElementById("source-video");
const resultPreviewCard = document.getElementById("result-preview-card");
const resultPreviewText = document.getElementById("result-preview-text");
const resultVideoEl = document.getElementById("result-video");
const resultLanguageSelect = document.getElementById("result-language-select");
const downloadProgress = document.getElementById("download-progress");
const downloadBar = document.getElementById("download-bar");
const downloadLabel = document.getElementById("download-label");
const reuseMediaTokenInput = document.getElementById("reuse-media-token");

let optionsCache = null;
let asrModels = [];
let translationModels = [];
let ttsModels = [];
let activeUploadToken = "";
let currentSourceDescriptor = "";
let activeRunId = "";
let selectedTargetLangs = [];
let latestResultPayload = null;

const languageMap = new Map();
const languageDisplay = typeof Intl !== "undefined" && Intl.DisplayNames
    ? new Intl.DisplayNames([navigator.language || "en"], { type: "language" })
    : null;
let sourceObjectUrl = null;
let resultObjectUrl = null;

function toLanguageLabel(code) {
    if (!code) return "";
    const lower = code.toLowerCase();
    const label = languageDisplay ? languageDisplay.of(lower) : null;
    if (!label) return lower;
    return label.charAt(0).toUpperCase() + label.slice(1);
}

function registerLanguage(code) {
    if (!code) return "";
    const normalized = code.toLowerCase();
    const label = toLanguageLabel(normalized);
    const display = `${label} (${normalized})`;
    const keys = [
        normalized,
        label.toLowerCase(),
        display.toLowerCase(),
        `${label} (${normalized.toUpperCase()})`.toLowerCase(),
    ];
    keys.forEach(key => {
        if (!languageMap.has(key)) {
            languageMap.set(key, normalized);
        }
    });
    return display;
}

function resolveLanguageCode(value) {
    if (!value) return "";
    const strValue = typeof value === "string" ? value : String(value);
    const trimmed = strValue.trim();
    if (!trimmed) return "";
    const match = trimmed.match(/\(([a-zA-Z-]+)\)\s*$/);
    if (match && match[1]) {
        const candidate = match[1].toLowerCase();
        if (languageMap.has(candidate)) {
            return languageMap.get(candidate);
        }
        return candidate;
    }
    const key = trimmed.toLowerCase();
    if (languageMap.has(key)) {
        return languageMap.get(key);
    }
    return key;
}

function refreshModelSelect(select, models, languageCode) {
    if (!select) return;
    const previous = select.value;
    select.innerHTML = "";
    const autoOption = document.createElement("option");
    autoOption.value = "auto";
    autoOption.textContent = "Auto";
    select.appendChild(autoOption);

    models.forEach(model => {
        const supportsLanguage =
            !languageCode ||
            !(model.languages || []).length ||
            model.languages.includes(languageCode);
        if (!supportsLanguage) {
            return;
        }
        const option = document.createElement("option");
        option.value = model.key;
        option.textContent = model.key;
        select.appendChild(option);
    });

    if ([...select.options].some(opt => opt.value === previous)) {
        select.value = previous;
    }
}

function getPrimaryTargetLang() {
    if (selectedTargetLangs.length > 0) {
        return selectedTargetLangs[0];
    }
    if (targetLangInput) {
        return resolveLanguageCode(targetLangInput.value);
    }
    return "";
}

function renderTargetLanguageTags() {
    if (!targetLangTags) return;
    targetLangTags.innerHTML = "";
    selectedTargetLangs.forEach(code => {
        const display = registerLanguage(code);
        const badge = document.createElement("span");
        badge.className = "tag-badge";
        badge.textContent = display;
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.setAttribute("aria-label", `Remove ${display}`);
        removeBtn.textContent = "Ã—";
        removeBtn.addEventListener("click", () => {
            selectedTargetLangs = selectedTargetLangs.filter(item => item !== code);
            renderTargetLanguageTags();
            updateModelSelectorsForTarget();
        });
        const hidden = document.createElement("input");
        hidden.type = "hidden";
        hidden.name = "target_langs";
        hidden.value = code;
        badge.appendChild(removeBtn);
        badge.appendChild(hidden);
        targetLangTags.appendChild(badge);
    });
}

function addTargetLanguage(rawValue) {
    const code = resolveLanguageCode(rawValue);
    if (!code) {
        if (targetLangInput) {
            targetLangInput.value = "";
        }
        return;
    }
    const normalized = code.toLowerCase();
    if (!selectedTargetLangs.includes(normalized)) {
        selectedTargetLangs.push(normalized);
        renderTargetLanguageTags();
        updateModelSelectorsForTarget();
    }
    if (targetLangInput) {
        targetLangInput.value = "";
    }
}

function updateModelSelectorsForTarget() {
    const primary = getPrimaryTargetLang();
    const sourceCode = resolveLanguageCode(sourceLangInput ? sourceLangInput.value : "");
    const trSelect = document.getElementById("tr-model");
    const ttsSelect = document.getElementById("tts-model");
    refreshModelSelect(trSelect, translationModels, primary || sourceCode);
    refreshModelSelect(ttsSelect, ttsModels, primary);
}

function updateSourcePreview(src, label, { keepExisting = false, objectUrl = null } = {}) {
    if (!keepExisting && sourceObjectUrl) {
        URL.revokeObjectURL(sourceObjectUrl);
        sourceObjectUrl = null;
    }

    if (!src) {
        sourceVideoEl.removeAttribute("src");
        sourceVideoEl.load();
        sourcePreviewCard.classList.add("empty");
        sourcePreviewText.textContent = label || "Waiting for mediaâ€¦";
        return;
    }

    sourceVideoEl.src = src;
    sourceVideoEl.load();
    sourcePreviewCard.classList.remove("empty");
    sourcePreviewText.textContent = label || "";
    if (objectUrl) {
        sourceObjectUrl = objectUrl;
    }
}

function updateDownloadProgress({ active, progress = null, label = "" }) {
    if (!downloadProgress) return;
    if (!active) {
        downloadProgress.hidden = true;
        downloadBar.style.width = "0%";
        downloadBar.style.animation = "none";
        if (label) {
            downloadLabel.textContent = label;
            downloadLabel.hidden = false;
        } else {
            downloadLabel.hidden = true;
        }
        return;
    }
    downloadProgress.hidden = false;
        downloadLabel.hidden = false;
        downloadLabel.textContent = label || "Downloadingâ€¦";
        if (progress !== null) {
            const pct = Math.min(100, Math.max(0, progress));
            downloadBar.style.width = `${pct}%`;
            downloadBar.style.animation = "none";
        } else {
            downloadBar.style.width = "30%";
            downloadBar.style.animation = "progressPulse 1s ease-in-out infinite alternate";
        }
}

function updateResultPreview(src, label, { objectUrl = null } = {}) {
    if (resultObjectUrl) {
        URL.revokeObjectURL(resultObjectUrl);
        resultObjectUrl = null;
    }

    if (!src) {
        resultVideoEl.removeAttribute("src");
        resultVideoEl.load();
        resultPreviewCard.classList.add("empty");
        resultPreviewText.textContent = label || "No output yet.";
        return;
    }

    resultVideoEl.src = src;
    resultVideoEl.load();
    resultPreviewCard.classList.remove("empty");
    resultPreviewText.textContent = label || "";
    if (objectUrl) {
        resultObjectUrl = objectUrl;
    }
}

function updateResultPreviewForLanguage(lang) {
    if (!lang || !latestResultPayload) {
        updateResultPreview(null, "No output yet.");
        return;
    }
    const languages = latestResultPayload.languages || {};
    const entry = languages[lang];
    const label = toLanguageLabel(lang) || lang;
    if (!entry || !entry.final_video || !entry.final_video.url) {
        updateResultPreview(null, `No preview for ${label}`);
        return;
    }
    updateResultPreview(entry.final_video.url, `Previewing ${label}`);
}

function updateResultLanguageSelector(payload) {
    if (!resultLanguageSelect) return;
    const languages = Object.keys(payload.languages || {});
    resultLanguageSelect.innerHTML = "";
    if (!languages.length) {
        resultLanguageSelect.disabled = true;
        const placeholder = document.createElement("option");
        placeholder.value = "";
        const hasDefaultVideo = payload.final_video && payload.final_video.url;
        placeholder.textContent = hasDefaultVideo ? "Default output" : "No output";
        resultLanguageSelect.appendChild(placeholder);
        if (hasDefaultVideo) {
            updateResultPreview(payload.final_video.url, "Rendered output");
        } else {
            updateResultPreview(null, "No output yet.");
        }
        return;
    }
    languages.forEach(lang => {
        const option = document.createElement("option");
        option.value = lang;
        option.textContent = toLanguageLabel(lang) || lang;
        resultLanguageSelect.appendChild(option);
    });
    const preferred = payload.default_language && languages.includes(payload.default_language)
        ? payload.default_language
        : languages[0];
    resultLanguageSelect.value = preferred;
    resultLanguageSelect.disabled = false;
    updateResultPreviewForLanguage(preferred);
}

function setActiveUploadToken(token = "") {
    activeUploadToken = token || "";
    if (reuseMediaTokenInput) {
        reuseMediaTokenInput.value = activeUploadToken;
    }
}

function showInterruptButton(disabled = true) {
    if (!interruptBtn) return;
    interruptBtn.hidden = false;
    interruptBtn.disabled = !!disabled;
    interruptBtn.textContent = "Interrupt run";
}

function hideInterruptButton() {
    if (!interruptBtn) return;
    interruptBtn.hidden = true;
    interruptBtn.disabled = true;
    interruptBtn.textContent = "Interrupt run";
}

async function releaseActiveUploadToken() {
    if (!activeUploadToken) return;
    const token = activeUploadToken;
    setActiveUploadToken("");
    currentSourceDescriptor = "";
    try {
        const params = new URLSearchParams({ token });
        const url = "/ui/release_media";
        let sent = false;
        if (navigator.sendBeacon) {
            const blob = new Blob([params.toString()], { type: "application/x-www-form-urlencoded" });
            sent = navigator.sendBeacon(url, blob);
        }
        if (!sent) {
            await fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: params,
            });
        }
    } catch (err) {
        console.warn("Failed to release cached media token", err);
    }
}

window.addEventListener("beforeunload", () => {
    if (!activeUploadToken) return;
    const params = new URLSearchParams({ token: activeUploadToken });
    const blob = new Blob([params.toString()], { type: "application/x-www-form-urlencoded" });
    if (!navigator.sendBeacon || !navigator.sendBeacon("/ui/release_media", blob)) {
        fetch("/ui/release_media", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: params,
            keepalive: true,
        }).catch(() => {});
    }
});

const THEME_KEY = "bluez-ui-theme";
const themeIconSpan = themeToggle ? themeToggle.querySelector("span[aria-hidden='true']") : null;

function applyTheme(theme) {
    const normalized = theme === "light" ? "light" : "dark";
    document.body.dataset.theme = normalized;
    document.body.style.colorScheme = normalized;
    if (themeLabel) {
        themeLabel.textContent = normalized === "dark" ? "Dark" : "Light";
    }
    if (themeIconSpan) {
        themeIconSpan.textContent = normalized === "dark" ? "ðŸŒ™" : "â˜€ï¸";
    }
}

if (themeToggle) {
    const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    const storedTheme = localStorage.getItem(THEME_KEY) || (prefersDark ? "dark" : "light");
    applyTheme(storedTheme);

    themeToggle.addEventListener("click", () => {
        const next = document.body.dataset.theme === "dark" ? "light" : "dark";
        applyTheme(next);
        localStorage.setItem(THEME_KEY, next);
    });
} else {
    document.body.dataset.theme = "dark";
    document.body.style.colorScheme = "dark";
}

updateSourcePreview(null, "Waiting for mediaâ€¦");
updateResultPreview(null, "No output yet.");
renderTargetLanguageTags();
if (resultLanguageSelect) {
    resultLanguageSelect.addEventListener("change", () => {
        updateResultPreviewForLanguage(resultLanguageSelect.value);
    });
}

async function fetchOptions() {
    const resp = await fetch("/ui/options");
    if (!resp.ok) throw new Error("Unable to load model registry");
    optionsCache = await resp.json();
    populateSelectors(optionsCache);
}

function populateSelectors(opts) {
    const asrSelect = document.getElementById("asr-model");
    const trSelect = document.getElementById("tr-model");
    const ttsSelect = document.getElementById("tts-model");
    const sepSelect = document.getElementById("sep-model");
    const translationStrategy = document.getElementById("translation-strategy");
    const dubbingStrategy = document.getElementById("dubbing-strategy");
    const subtitleStyle = document.getElementById("subtitle-style");
    const languageList = document.getElementById("language-list");

    asrModels = opts.asr_models || [];
    translationModels = opts.translation_models || [];
    ttsModels = opts.tts_models || [];

    const codes = new Set();
    [asrModels, translationModels, ttsModels].forEach(group => {
        group.forEach(model => (model.languages || []).forEach(lang => codes.add(lang)));
    });

    const initSourceCode = resolveLanguageCode(sourceLangInput ? sourceLangInput.value : "");
    const initTargetCode = getPrimaryTargetLang() || initSourceCode;
    refreshModelSelect(asrSelect, asrModels, initSourceCode);
    refreshModelSelect(trSelect, translationModels, initTargetCode);
    refreshModelSelect(ttsSelect, ttsModels, initTargetCode);

    opts.audio_separation_models.forEach(group => {
        const optGroup = document.createElement("optgroup");
        optGroup.label = group.architecture;
        group.models.forEach(model => {
            const opt = document.createElement("option");
            opt.value = model.filename;
            opt.textContent = `${model.filename} (${model.stems.join(" + ")})`;
            optGroup.appendChild(opt);
        });
        sepSelect.appendChild(optGroup);
    });

    opts.translation_strategies.forEach(strategy => {
        const option = document.createElement("option");
        option.value = strategy;
        option.textContent = strategy;
        translationStrategy.appendChild(option);
    });

    opts.dubbing_strategies.forEach(strategy => {
        const option = document.createElement("option");
        option.value = strategy;
        option.textContent = strategy;
        dubbingStrategy.appendChild(option);
    });

    opts.subtitle_styles.forEach(style => {
        ["Desktop", "Mobile"].forEach(mode => {
            const value = mode === "Mobile" ? `${style}_mobile` : style;
            const option = document.createElement("option");
            option.value = value;
            option.textContent = `${style} (${mode})`;
            subtitleStyle.appendChild(option);
        });
    });

    const preferredOrder = ["en", "fr"];
    const languageEntries = Array.from(codes).map(code => ({
        code: code.toLowerCase(),
        display: registerLanguage(code),
    }));

    languageEntries.sort((a, b) => {
        const idxA = preferredOrder.indexOf(a.code);
        const idxB = preferredOrder.indexOf(b.code);
        if (idxA !== -1 && idxB !== -1) return idxA - idxB;
        if (idxA !== -1) return -1;
        if (idxB !== -1) return 1;
        return a.display.localeCompare(b.display);
    });

    function fillLanguageOptions(filter = "") {
        const normalized = filter.trim().toLowerCase();
        const suggestions = normalized
            ? languageEntries.filter(entry =>
                  entry.display.toLowerCase().includes(normalized) || entry.code.includes(normalized)
              )
            : languageEntries;
        languageList.innerHTML = "";
        suggestions.forEach(entry => {
            const opt = document.createElement("option");
            opt.value = entry.display;
            opt.dataset.code = entry.code;
            languageList.appendChild(opt);
        });
    }

    fillLanguageOptions();
    updateModelSelectorsForTarget();

    function updateLanguageSuggestions(inputEl) {
        if (!inputEl) return;
        fillLanguageOptions(inputEl.value);
    }

    if (sourceLangInput) {
        sourceLangInput.addEventListener("input", () => {
            updateLanguageSuggestions(sourceLangInput);
            const sourceCode = resolveLanguageCode(sourceLangInput.value);
            refreshModelSelect(asrSelect, asrModels, sourceCode);
            updateModelSelectorsForTarget();
        });
    }
    if (targetLangInput) {
        targetLangInput.addEventListener("input", () => {
            updateLanguageSuggestions(targetLangInput);
        });
        targetLangInput.addEventListener("keydown", event => {
            if (["Enter", "Tab", ","].includes(event.key)) {
                const pending = targetLangInput.value.trim();
                if (!pending) {
                    if (event.key === "Enter" || event.key === ",") {
                        event.preventDefault();
                    }
                    return;
                }
                event.preventDefault();
                addTargetLanguage(pending);
            } else if (event.key === "Backspace" && !targetLangInput.value && selectedTargetLangs.length) {
                selectedTargetLangs.pop();
                renderTargetLanguageTags();
                updateModelSelectorsForTarget();
            }
        });
        targetLangInput.addEventListener("blur", () => {
            if (targetLangInput.value.trim()) {
                addTargetLanguage(targetLangInput.value);
            }
        });
    }
}

function appendLog(message) {
    const now = new Date().toLocaleTimeString();
    logEl.textContent += `\n[${now}] ${message}`;
    logEl.scrollTop = logEl.scrollHeight;
}

if (interruptBtn) {
    interruptBtn.addEventListener("click", async () => {
        if (!activeRunId) {
            appendLog("âš ï¸ No active run to interrupt.");
            return;
        }
        const previousLabel = interruptBtn.textContent;
        interruptBtn.disabled = true;
        interruptBtn.textContent = "Stoppingâ€¦";
        try {
            const body = new URLSearchParams({ run_id: activeRunId });
            await fetch("/ui/stop", {
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body,
                keepalive: true,
            });
            appendLog("â¹ Cancellation requested." );
            setStatus("Stoppingâ€¦", "running");
        } catch (err) {
            appendLog(`âŒ Failed to interrupt: ${err.message}`);
            interruptBtn.disabled = false;
        } finally {
            interruptBtn.textContent = previousLabel;
        }
    });
}

fileInput.addEventListener("change", () => {
    if (activeUploadToken) {
        releaseActiveUploadToken();
    } else {
        setActiveUploadToken("");
        currentSourceDescriptor = "";
    }
    if (sourceObjectUrl) {
        URL.revokeObjectURL(sourceObjectUrl);
        sourceObjectUrl = null;
    }
    if (fileInput.files && fileInput.files.length > 0) {
        const blobUrl = URL.createObjectURL(fileInput.files[0]);
        updateSourcePreview(blobUrl, "Local upload", { objectUrl: blobUrl });
        currentSourceDescriptor = fileInput.files[0].name || "";
    } else if (!videoLinkInput.value.trim()) {
        updateSourcePreview(null, "Waiting for mediaâ€¦");
    }
});

videoLinkInput.addEventListener("input", () => {
    const trimmedValue = videoLinkInput.value.trim();
    if (activeUploadToken && trimmedValue !== currentSourceDescriptor) {
        releaseActiveUploadToken();
        currentSourceDescriptor = trimmedValue;
    } else if (!trimmedValue) {
        setActiveUploadToken("");
        currentSourceDescriptor = "";
    } else {
        currentSourceDescriptor = trimmedValue;
    }
    if (trimmedValue && (!fileInput.files || fileInput.files.length === 0)) {
        updateSourcePreview(null, "Remote media will be downloaded on runâ€¦");
        updateDownloadProgress({ active: false, label: "" });
    }
});

function resetLog() {
    logEl.textContent = "Waitingâ€¦";
}

function setStatus(text, tone = "idle") {
    statusBadge.textContent = text;
    const palette = {
        idle: "rgba(59, 130, 246, 0.18)",
        running: "rgba(52, 211, 153, 0.2)",
        success: "rgba(34, 197, 94, 0.25)",
        error: "rgba(239, 68, 68, 0.25)"
    };
    statusBadge.style.background = palette[tone] || palette.idle;
    statusBadge.style.borderColor = palette[tone] || palette.idle;
}

function renderResults(payload) {
    if (!payload) {
        resultsEl.textContent = "Pipeline finished without a payload.";
        return;
    }
    latestResultPayload = payload;
    const { languages = {}, default_language: defaultLanguage, final_video, final_audio, speech_track, subtitles, models, timings, workspace_id, source_media, source_video, available_languages: availableLanguages = [] } = payload;

    function renderLink(item, label) {
        if (!item || !item.url) return `<li>${label}: unavailable</li>`;
        return `<li>${label}: <a href="${item.url}" target="_blank" rel="noopener">${item.path}</a></li>`;
    }

    function renderLanguageSection(lang, data) {
        const label = toLanguageLabel(lang) || lang;
        const entries = [];
        entries.push(renderLink(data.final_video, "Final video"));
        entries.push(renderLink(data.final_audio, "Dubbed audio"));
        entries.push(renderLink(data.speech_track, "Speech track"));
        const alignedSubs = data.subtitles?.aligned || {};
        entries.push(renderLink(alignedSubs.srt, "Aligned SRT"));
        entries.push(renderLink(alignedSubs.vtt, "Aligned VTT"));
        return `<li><strong>${label}</strong><ul>${entries.join("")}</ul></li>`;
    }

    const languagesMarkup = Object.entries(languages)
        .map(([lang, data]) => renderLanguageSection(lang, data))
        .join("") || "<li>No target languages processed.</li>";

    const modelValue = value => {
        if (!value) return "n/a";
        if (typeof value === "string") return value;
        if (typeof value === "object") {
            return Object.entries(value)
                .map(([key, val]) => `${key}: ${val}`)
                .join(", ") || "n/a";
        }
        return String(value);
    };

    resultsEl.innerHTML = `
        <p><strong>Workspace:</strong> ${workspace_id || "n/a"}</p>
        <p><strong>Source:</strong> ${source_media || "n/a"}</p>
        <p><strong>Default language:</strong> ${defaultLanguage ? `${toLanguageLabel(defaultLanguage) || defaultLanguage} (${defaultLanguage})` : "n/a"}</p>
        <p><strong>Models:</strong> ASR=${modelValue(models?.asr)}, Translation=${modelValue(models?.translation)}, TTS=${modelValue(models?.tts)}</p>
        <p><strong>Available languages:</strong> ${availableLanguages.length ? availableLanguages.join(", ") : "n/a"}</p>
        <ul>
            ${renderLink(source_video, "Source video")}
            ${renderLink(final_video, "Default final video")}
            ${renderLink(final_audio, "Default dubbed audio")}
            ${renderLink(speech_track, "Default speech track")}
        </ul>
        <details open>
            <summary>Per-language outputs</summary>
            <ul>
                ${languagesMarkup}
            </ul>
        </details>
        <details>
            <summary>Subtitles (default)</summary>
            <ul>
                ${renderLink(subtitles?.original?.srt, "Original SRT")}
                ${renderLink(subtitles?.original?.vtt, "Original VTT")}
                ${renderLink(subtitles?.aligned?.srt, "Aligned SRT")}
                ${renderLink(subtitles?.aligned?.vtt, "Aligned VTT")}
            </ul>
        </details>
        <details>
            <summary>Timings</summary>
            <ul>
                ${Object.entries(timings || {}).map(([step, duration]) => `<li>${step}: ${duration.toFixed(2)}s</li>`).join("")}
            </ul>
        </details>
    `;

    updateResultLanguageSelector(payload);
}

formEl.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!optionsCache) {
        appendLog("âš ï¸ Model registry not loaded.");
        return;
    }

    let linkValue = videoLinkInput.value.trim();
    let hasFile = fileInput.files && fileInput.files.length > 0;

    if (linkValue && hasFile) {
        if (activeUploadToken) {
            await releaseActiveUploadToken();
        }
        fileInput.value = "";
        hasFile = false;
    }

    if (targetLangInput && targetLangInput.value.trim()) {
        addTargetLanguage(targetLangInput.value);
    }

    const formData = new FormData(formEl);
    linkValue = videoLinkInput.value.trim();
    const cachedToken = reuseMediaTokenInput ? reuseMediaTokenInput.value.trim() : "";
    if (!hasFile && !linkValue && !cachedToken) {
        appendLog("âš ï¸ Provide a media file or a video link.");
        setStatus("Error", "error");
        return;
    }

    if (linkValue) {
        formData.set("video_url", linkValue);
    } else {
        formData.delete("video_url");
    }

    if (linkValue) {
        formData.delete("file");
    } else if (!hasFile) {
        formData.delete("file");
    }

    if (cachedToken && !hasFile && !linkValue) {
        formData.set("reuse_media_token", cachedToken);
    } else {
        formData.delete("reuse_media_token");
    }

    const resolvedSource = resolveLanguageCode(formData.get("source_lang"));
    formData.set("source_lang", resolvedSource);

    formData.delete("target_langs");
    selectedTargetLangs.forEach(lang => formData.append("target_langs", lang));
    const primaryTarget = selectedTargetLangs[0] || "";
    if (primaryTarget) {
        formData.set("target_lang", primaryTarget);
    } else {
        formData.delete("target_lang");
    }

    formData.set("audio_sep", document.getElementById("audio-sep").checked ? "true" : "false");
    formData.set("perform_vad_trimming", document.getElementById("vad-trim").checked ? "true" : "false");
    formData.set("sophisticated_dub_timing", document.getElementById("sophisticated-timing").checked ? "true" : "false");
    formData.set("persist_intermediate", document.getElementById("persist-intermediate").checked ? "true" : "false");

    const normalizeSpeakerField = (field, label) => {
        const raw = formData.get(field);
        if (raw === null) {
            return { value: null, ok: true };
        }
        const trimmed = String(raw).trim();
        if (!trimmed) {
            formData.delete(field);
            return { value: null, ok: true };
        }
        const parsed = Number(trimmed);
        if (!Number.isInteger(parsed) || parsed < 1) {
            appendLog(`âš ï¸ ${label} must be a positive integer.`);
            setStatus("Error", "error");
            return { value: null, ok: false };
        }
        formData.set(field, String(parsed));
        return { value: parsed, ok: true };
    };

    const minHint = normalizeSpeakerField("min_speakers", "Min speakers");
    if (!minHint.ok) {
        return;
    }
    const maxHint = normalizeSpeakerField("max_speakers", "Max speakers");
    if (!maxHint.ok) {
        return;
    }
    if (minHint.value !== null && maxHint.value !== null && minHint.value > maxHint.value) {
        appendLog("âš ï¸ Min speakers cannot exceed max speakers.");
        setStatus("Error", "error");
        return;
    }

    latestResultPayload = null;
    availableResultLanguages = [];
    if (resultLanguageSelect) {
        resultLanguageSelect.innerHTML = '<option value="">Processingâ€¦</option>';
        resultLanguageSelect.disabled = true;
    }

    resultsEl.textContent = "Processing current runâ€¦";
    activeRunId = "";
    showInterruptButton(true);
    resetLog();
    logEl.textContent = "Starting pipelineâ€¦";
    setStatus("Running", "running");
    if (!hasFile && linkValue) {
        updateSourcePreview(null, "Downloading mediaâ€¦");
    }
    updateResultPreview(null, "Processing outputâ€¦");
    runBtn.disabled = true;

    try {
        const response = await fetch("/ui/run", {
            method: "POST",
            body: formData,
        });
        if (!response.ok) {
            throw new Error(`Request failed: ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n\n");
            buffer = lines.pop() || "";

            for (const block of lines) {
                const line = block.split("\n").find(l => l.startsWith("data:"));
                if (!line) continue;
                const data = JSON.parse(line.slice(5).trim());
                handleEvent(data);
            }
        }

        if (buffer.trim()) {
            const line = buffer.split("\n").find(l => l.startsWith("data:"));
            if (line) {
                const data = JSON.parse(line.slice(5).trim());
                handleEvent(data);
            }
        }
    } catch (err) {
        appendLog(`âŒ ${err.message}`);
        setStatus("Error", "error");
    } finally {
        runBtn.disabled = false;
        hideInterruptButton();
        activeRunId = "";
    }
});

function handleEvent(event) {
    if (!event || !event.type) return;
    switch (event.type) {
        case "run_id":
            activeRunId = event.run_id || "";
            if (activeRunId) {
                showInterruptButton(false);
                appendLog(`ðŸ†” Run started (${activeRunId})`);
            }
            break;
        case "step":
            if (event.event === "start") {
                appendLog(`â–¶ï¸  ${event.step}â€¦`);
            } else if (event.event === "end") {
                appendLog(`âœ… ${event.step} (${event.duration.toFixed(2)}s)`);
            }
            break;
        case "cancelled":
            appendLog("â¹ Run cancelled.");
            setStatus("Cancelled", "error");
            resultsEl.textContent = "Run cancelled.";
            updateResultPreview(null, "Cancelled.");
            hideInterruptButton();
            activeRunId = "";
            break;
        case "result":
            appendLog("ðŸŽ‰ Pipeline completed.");
            setStatus("Done", "success");
            renderResults(event.result);
            {
                const token = event.result?.upload_token || "";
                setActiveUploadToken(token);
                currentSourceDescriptor = (event.result?.source_media || "").trim();
                if (token && fileInput) {
                    fileInput.value = "";
                }
            }
            if (event.result?.source_video?.url) {
                updateSourcePreview(event.result.source_video.url, "Source (workspace)");
            }
            break;
        case "status":
            if (event.event === "download_start") {
                appendLog(`â¬‡ï¸ Downloading remote media: ${event.url || ""}`);
                updateSourcePreview(null, "Downloading mediaâ€¦", { keepExisting: false });
                updateDownloadProgress({ active: true, label: "Downloadingâ€¦" });
            } else if (event.event === "download_complete") {
                appendLog(`âœ… Download complete`);
                sourcePreviewText.textContent = "Download complete. Preparing sourceâ€¦";
                updateDownloadProgress({ active: false, label: "Download complete." });
            } else if (event.event === "download_progress") {
                if (typeof event.total === "number" && typeof event.downloaded === "number") {
                    const pct = Math.round((event.downloaded / event.total) * 100);
                    updateDownloadProgress({ active: true, progress: pct, label: `Downloadingâ€¦ ${pct}%` });
                } else {
                    updateDownloadProgress({ active: true, progress: null, label: "Downloadingâ€¦" });
                }
            } else {
                appendLog(`â„¹ï¸ ${event.event || "status"}`);
            }
            break;
        case "source_preview":
            if (event.preview && event.preview.url) {
                updateSourcePreview(event.preview.url, "Source ready");
                appendLog("ðŸŽ¬ Source preview available.");
            }
            break;
        case "error":
            appendLog(`âŒ Error: ${event.message || "unknown failure"}`);
            setStatus("Error", "error");
            hideInterruptButton();
            activeRunId = "";
            break;
        case "complete":
            appendLog("ðŸ Stream closed.");
            hideInterruptButton();
            activeRunId = "";
            break;
        default:
            appendLog(`â„¹ï¸ ${JSON.stringify(event)}`);
    }
}

fetchOptions().catch(err => appendLog(`âš ï¸ ${err.message}`));
</script>
</body>
</html>
